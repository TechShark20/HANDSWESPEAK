# -*- coding: utf-8 -*-
"""handnorm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WWR2Ce2QWAAk86Z5mddMo0Uay-BhrIaN
"""

import pandas as pd

HAND_IDENTIFIERS = [
    "wirst",
    "index1",
    "index2",
    "index3",
    "index4",
    "middle1",
    "middle2",
    "middle3",
    "middle4",
    "ring1",
    "ring2",
    "ring3",
    "ring4",
    "little1",
    "little2",
    "little3",
    "little4",
    "thumb1",
    "thumb2",
    "thumb3",
    "thumb4"
]


def normalize_single_dict(row: dict):
    """
    Normalizes the skeletal data for a given sequence of frames with signer's hand pose data. The normalization follows
    the definition from our paper.
    :param row: Dictionary containing key-value pairs with joint identifiers and corresponding lists (sequences) of
                that particular joints coordinates
    :return: Dictionary with normalized skeletal data (following the same schema as input data)
    """

    idefl = [id + "_Left" for id in HAND_IDENTIFIERS] 
    idefr = [id + "_Right" for id in HAND_IDENTIFIERS]
    ident = []
    ident.append(idefl)
    ident.append(idefr)

    # Determine how many hands are present in the dataset
    range_hand_size = 2

    # Construct the relevant identifiers

    # Treat each hand individually
    for hand_index in ident:
        sequence_size = len(row[idefl[0]])

        # Treat each element of the sequence (analyzed frame) individually
        for sequence_index in range(sequence_size):

            # Retrieve all of the X and Y values of the current frame
            landmarks_x_values = [row[key][sequence_index][0] for key in hand_index if row[key][sequence_index][0] != 0]
            landmarks_y_values = [row[key][sequence_index][1] for key in hand_index if row[key][sequence_index][1] != 0]

            # Prevent from even starting the analysis if some necessary elements are not present
            if not landmarks_x_values or not landmarks_y_values:
                continue

            # Calculate the deltas
            width, height = max(landmarks_x_values) - min(landmarks_x_values), max(landmarks_y_values) - min(landmarks_y_values)
            if width > height:
                delta_x = 0.1 * width
                delta_y = delta_x + ((width - height) / 2)
            else:
                delta_y = 0.1 * height
                delta_x = delta_y + ((height - width) / 2)

            # Set the starting and ending point of the normalization bounding box
            starting_point = [min(landmarks_x_values) - delta_x, min(landmarks_y_values) - delta_y]
            ending_point = [max(landmarks_x_values) + delta_x, max(landmarks_y_values) + delta_y]

            # Ensure that all of the bounding-box-defining coordinates are not out of the picture
            if starting_point[0] < 0:
                starting_point[0] = 0
            if starting_point[1] > 1:
                starting_point[1] = 1
            if ending_point[0] < 0:
                ending_point[0] = 0
            if ending_point[1] > 1:
                ending_point[1] = 1

            # Normalize individual landmarks and save the results
            for key in hand_index :
                # Prevent from trying to normalize incorrectly captured points
                if row[key][sequence_index][0] == 0 or (ending_point[0] - starting_point[0]) == 0 or (starting_point[1] - ending_point[1]) == 0:
                    continue

                normalized_x = (row[key][sequence_index][0] - starting_point[0]) / (ending_point[0] - starting_point[0])
                normalized_y = (row[key][sequence_index][1] - starting_point[1]) / (ending_point[1] - starting_point[1])
                row[key][sequence_index] = list(row[key][sequence_index])

                row[key][sequence_index][0] = normalized_x
                row[key][sequence_index][1] = normalized_y

    return row

